'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

// –°–æ–±—ã—Ç–∏—è –¥–ª—è WebRTC signaling
const VOICE_ACTIONS = {
  JOIN: 'voice-join',
  LEAVE: 'voice-leave', 
  ADD_PEER: 'voice-add-peer',
  REMOVE_PEER: 'voice-remove-peer',
  RELAY_SDP: 'voice-relay-sdp',
  RELAY_ICE: 'voice-relay-ice',
  ICE_CANDIDATE: 'voice-ice-candidate',
  SESSION_DESCRIPTION: 'voice-session-description'
};

const LOCAL_AUDIO = 'LOCAL_AUDIO';

export interface VoiceParticipant {
  id: string;
  name: string;
  isLocal: boolean;
  isMuted: boolean;
  isSpeaking: boolean;
  connectionState: string;
  volume: number;
}

export interface VoiceChatHook {
  participants: VoiceParticipant[];
  isConnected: boolean;
  connectionStates: Record<string, string>;
  isInitializing: boolean;
  isMuted: boolean;
  joinVoiceChat: (roomId: string, playerName: string) => Promise<void>;
  leaveVoiceChat: () => void;
  toggleMute: () => void;
  forcePlayAllAudio: () => void;
  setParticipantVolume: (participantId: string, volume: number) => void;
  volumes: Record<string, number>;
}

export const useVoiceChat = (): VoiceChatHook => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [participants, setParticipants] = useState<string[]>([]);
  const [participantNames, setParticipantNames] = useState<Record<string, string>>({});
  const [connectionStates, setConnectionStates] = useState<Record<string, string>>({});
  const [isInitializing, setIsInitializing] = useState(false);
  const [currentRoomId, setCurrentRoomId] = useState<string | null>(null);
  const [currentPlayerName, setCurrentPlayerName] = useState<string | null>(null);
  const [volumes, setVolumes] = useState<Record<string, number>>({});

  // Refs –¥–ª—è WebRTC
  const peerConnections = useRef<Record<string, RTCPeerConnection>>({});
  const localMediaStream = useRef<MediaStream | null>(null);
  const audioElements = useRef<Record<string, HTMLAudioElement>>({});

  // –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –∏–∑ localStorage
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedVolumes = localStorage.getItem('voiceChat-volumes');
      if (savedVolumes) {
        try {
          const parsedVolumes = JSON.parse(savedVolumes);
          setVolumes(parsedVolumes);
        } catch (error) {
          console.error('Failed to parse saved volumes:', error);
        }
      }
    }
  }, []);

  // –§—É–Ω–∫—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞
  const setParticipantVolume = useCallback((participantId: string, volume: number) => {
    setVolumes(prev => {
      const newVolumes = { ...prev, [participantId]: volume };
      
      // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ localStorage
      if (typeof window !== 'undefined') {
        localStorage.setItem('voiceChat-volumes', JSON.stringify(newVolumes));
      }
      
      // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –∫ –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç—É
      if (audioElements.current[participantId]) {
        audioElements.current[participantId].volume = volume;
      }
      
      return newVolumes;
    });
  }, []);

  // –§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞ (—Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º)
  const getParticipantVolume = useCallback((participantId: string): number => {
    return volumes[participantId] ?? 0.8; // –î–µ—Ñ–æ–ª—Ç 80%
  }, [volumes]);

  // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
  const addParticipant = useCallback((participantId: string) => {
    setParticipants(prev => {
      if (!prev.includes(participantId)) {
        return [...prev, participantId];
      }
      return prev;
    });
  }, []);

  // –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
  const removeParticipant = useCallback((participantId: string) => {
    setParticipants(prev => prev.filter(p => p !== participantId));
  }, []);

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Socket.IO
  useEffect(() => {
    const newSocket = io('http://localhost:8001', {
      transports: ['websocket'],
      forceNew: true
    });

    newSocket.on('connect', () => {
      console.log('‚úÖ VoiceChat: Connected to signaling server');
      setSocket(newSocket);
    });

    newSocket.on('disconnect', () => {
      console.log('‚ùå VoiceChat: Disconnected from signaling server');
      setIsConnected(false);
    });

    return () => {
      newSocket.close();
    };
  }, []);

  // WebRTC –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
  useEffect(() => {
    if (!socket) return;

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ –ø–∏—Ä–∞
    const handleAddPeer = async ({ peerID, createOffer, playerName }: { peerID: string; createOffer: boolean; playerName?: string }) => {
      console.log(`üìû VoiceChat: Adding peer: ${peerID}, createOffer: ${createOffer}`);

      if (peerID in peerConnections.current) {
        console.warn(`VoiceChat: Already connected to peer ${peerID}`);
        return;
      }

      // –°–æ–∑–¥–∞–Ω–∏–µ RTCPeerConnection —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π –¥–ª—è Chromium
      const peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' }
        ],
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all'
      });

      peerConnections.current[peerID] = peerConnection;

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`üßä VoiceChat: Generated ICE candidate for ${peerID}:`, event.candidate.type, event.candidate.protocol);
          socket.emit(VOICE_ACTIONS.RELAY_ICE, {
            peerID,
            iceCandidate: event.candidate
          });
        } else {
          console.log(`üßä VoiceChat: ICE gathering complete for ${peerID}`);
        }
      };

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE connection state
      peerConnection.oniceconnectionstatechange = () => {
        console.log(`üßä VoiceChat: ICE connection state for ${peerID}:`, peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed') {
          console.warn(`‚ùå VoiceChat: ICE connection failed for ${peerID}, attempting restart`);
          peerConnection.restartIce();
        }
      };

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE gathering state  
      peerConnection.onicegatheringstatechange = () => {
        console.log(`üßä VoiceChat: ICE gathering state for ${peerID}:`, peerConnection.iceGatheringState);
      };

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –∞—É–¥–∏–æ –ø–æ—Ç–æ–∫–∞
      peerConnection.ontrack = ({ streams: [remoteStream], track }) => {
        console.log(`üéµ VoiceChat: Received remote track from ${peerID}: ${track.kind}, enabled: ${track.enabled}`);
        console.log(`üéµ VoiceChat: Remote stream tracks count: ${remoteStream.getTracks().length}`);
        
        // –°–æ–∑–¥–∞–Ω–∏–µ audio —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
        const audioElement = new Audio();
        audioElement.srcObject = remoteStream;
        audioElement.autoplay = true;
        
        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
        const savedVolume = getParticipantVolume(peerID);
        audioElement.volume = savedVolume;
        console.log(`üîä VoiceChat: Set volume for ${peerID}: ${savedVolume}`);
        
        // –ü–æ–ø—ã—Ç–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è (–≤–∞–∂–Ω–æ –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤)
        audioElement.play().then(() => {
          console.log(`‚úÖ VoiceChat: Successfully started playing audio from ${peerID}`);
        }).catch(error => {
          console.warn(`‚ö†Ô∏è VoiceChat: Could not auto-play audio for ${peerID}:`, error);
        });
        
        audioElements.current[peerID] = audioElement;
        addParticipant(peerID);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞, –µ—Å–ª–∏ –æ–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω–æ
        if (playerName) {
          setParticipantNames(prev => ({ ...prev, [peerID]: playerName }));
        }
      };

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log(`üîó VoiceChat: Peer ${peerID} connection state: ${state}`);
        setConnectionStates(prev => ({ ...prev, [peerID]: state }));
      };

      // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
      if (localMediaStream.current) {
        const tracks = localMediaStream.current.getTracks();
        console.log(`üì§ VoiceChat: Adding ${tracks.length} local tracks to peer ${peerID}`);
        tracks.forEach((track, index) => {
          console.log(`üì§ VoiceChat: Track ${index}: ${track.kind}, enabled: ${track.enabled}`);
          peerConnection.addTrack(track, localMediaStream.current!);
        });
      }

      // –°–æ–∑–¥–∞–Ω–∏–µ offer –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
      if (createOffer) {
        try {
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);
          
          socket.emit(VOICE_ACTIONS.RELAY_SDP, {
            peerID,
            sessionDescription: offer
          });
        } catch (error) {
          console.error('‚ùå VoiceChat: Error creating offer:', error);
        }
      }
    };

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ session description
    const handleSessionDescription = async ({ peerID, sessionDescription }: { peerID: string; sessionDescription: RTCSessionDescription }) => {
      console.log(`üìã VoiceChat: Received ${sessionDescription.type} from ${peerID}`);
      
      try {
        const peerConnection = peerConnections.current[peerID];
        if (!peerConnection) return;

        await peerConnection.setRemoteDescription(new RTCSessionDescription(sessionDescription));

        // –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ offer, —Å–æ–∑–¥–∞–µ–º answer
        if (sessionDescription.type === 'offer') {
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.emit(VOICE_ACTIONS.RELAY_SDP, {
            peerID,
            sessionDescription: answer
          });
        }
      } catch (error) {
        console.error('‚ùå VoiceChat: Error handling session description:', error);
      }
    };

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
    const handleIceCandidate = ({ peerID, iceCandidate }: { peerID: string; iceCandidate: RTCIceCandidate }) => {
      console.log(`üßä VoiceChat: Received ICE candidate from ${peerID}:`, iceCandidate.type, iceCandidate.protocol);
      
      const peerConnection = peerConnections.current[peerID];
      if (peerConnection && peerConnection.remoteDescription) {
        peerConnection.addIceCandidate(new RTCIceCandidate(iceCandidate))
          .then(() => {
            console.log(`‚úÖ VoiceChat: Successfully added ICE candidate for ${peerID}`);
          })
          .catch(error => {
            console.error(`‚ùå VoiceChat: Error adding ICE candidate for ${peerID}:`, error);
            // –í Chromium –∏–Ω–æ–≥–¥–∞ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞
            setTimeout(() => {
              if (peerConnection.remoteDescription) {
                peerConnection.addIceCandidate(new RTCIceCandidate(iceCandidate))
                  .catch(retryError => console.error(`‚ùå VoiceChat: Retry failed for ${peerID}:`, retryError));
              }
            }, 100);
          });
      } else {
        console.warn(`‚ö†Ô∏è VoiceChat: Cannot add ICE candidate for ${peerID}: no remote description or connection`);
      }
    };

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–∏—Ä–∞
    const handleRemovePeer = ({ peerID }: { peerID: string }) => {
      console.log(`üëã VoiceChat: Removing peer: ${peerID}`);
      
      if (peerConnections.current[peerID]) {
        peerConnections.current[peerID].close();
        delete peerConnections.current[peerID];
      }

      if (audioElements.current[peerID]) {
        audioElements.current[peerID].pause();
        delete audioElements.current[peerID];
      }

      removeParticipant(peerID);
      setConnectionStates(prev => {
        const newStates = { ...prev };
        delete newStates[peerID];
        return newStates;
      });
      setParticipantNames(prev => {
        const newNames = { ...prev };
        delete newNames[peerID];
        return newNames;
      });
    };

    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    socket.on(VOICE_ACTIONS.ADD_PEER, handleAddPeer);
    socket.on(VOICE_ACTIONS.SESSION_DESCRIPTION, handleSessionDescription);
    socket.on(VOICE_ACTIONS.ICE_CANDIDATE, handleIceCandidate);
    socket.on(VOICE_ACTIONS.REMOVE_PEER, handleRemovePeer);

    return () => {
      socket.off(VOICE_ACTIONS.ADD_PEER);
      socket.off(VOICE_ACTIONS.SESSION_DESCRIPTION);
      socket.off(VOICE_ACTIONS.ICE_CANDIDATE);
      socket.off(VOICE_ACTIONS.REMOVE_PEER);
    };
  }, [socket, addParticipant, removeParticipant]);

  // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –≥–æ–ª–æ—Å–æ–≤–æ–º—É —á–∞—Ç—É
  const joinVoiceChat = async (roomId: string, playerName: string) => {
    if (!socket) {
      console.warn('VoiceChat: No socket connection');
      return;
    }

    if (isConnected) {
      console.warn('VoiceChat: Already connected');
      return;
    }

    setIsInitializing(true);
    setCurrentRoomId(roomId);
    setCurrentPlayerName(playerName);

    try {
      // –ü–æ–ª—É—á–µ–Ω–∏–µ –∞—É–¥–∏–æ –ø–æ—Ç–æ–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –¥–ª—è Chromium
      console.log('üé§ VoiceChat: Requesting microphone access...');
      const audioConstraints = {
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 44100,
          channelCount: 1,
          // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è Chromium
          googEchoCancellation: true,
          googAutoGainControl: true,
          googNoiseSuppression: true,
          googHighpassFilter: true,
          googTypingNoiseDetection: true
        },
        video: false
      };

      // –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±—Ä–∞—É–∑–µ—Ä–µ
      const isChromium = typeof window !== 'undefined' && /Chrome|Chromium|Edge/.test(navigator.userAgent);
      console.log(`üåê VoiceChat: Browser: ${isChromium ? 'Chromium-based' : 'Other'}`);
      
      const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);

      localMediaStream.current = stream;
      console.log('‚úÖ VoiceChat: Got local audio stream');

      // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ —Å –∏–º–µ–Ω–µ–º –∏–≥—Ä–æ–∫–∞
      socket.emit(VOICE_ACTIONS.JOIN, { 
        room: roomId, 
        playerName: playerName 
      });
      setIsConnected(true);
      addParticipant(LOCAL_AUDIO);
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
      setParticipantNames(prev => ({ ...prev, [LOCAL_AUDIO]: playerName }));

    } catch (error) {
      console.error('‚ùå VoiceChat: Error accessing microphone:', error);
      throw error;
    } finally {
      setIsInitializing(false);
    }
  };

  // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —á–∞—Ç–∞
  const leaveVoiceChat = () => {
    if (!socket) return;

    console.log('üëã VoiceChat: Leaving voice chat...');

    // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
    if (localMediaStream.current) {
      localMediaStream.current.getTracks().forEach(track => track.stop());
      localMediaStream.current = null;
    }

    // –ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö peer connections
    Object.values(peerConnections.current).forEach(pc => pc.close());
    peerConnections.current = {};

    // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö audio —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    Object.values(audioElements.current).forEach(audio => audio.pause());
    audioElements.current = {};

    // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞
    socket.emit(VOICE_ACTIONS.LEAVE);

    setIsConnected(false);
    setParticipants([]);
    setConnectionStates({});
    setParticipantNames({});
    setCurrentRoomId(null);
    setCurrentPlayerName(null);
  };

  // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
  const toggleMute = () => {
    if (localMediaStream.current) {
      const audioTrack = localMediaStream.current.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        setIsMuted(!audioTrack.enabled);
      }
    }
  };

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—Å–µ—Ö –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  const forcePlayAllAudio = () => {
    Object.entries(audioElements.current).forEach(([peerID, audio]) => {
      audio.play().then(() => {
        console.log(`‚úÖ VoiceChat: Force played audio for ${peerID}`);
      }).catch(error => {
        console.warn(`‚ùå VoiceChat: Failed to force play audio for ${peerID}:`, error);
      });
    });
  };

    // –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
  const participantsWithInfo: VoiceParticipant[] = participants.map(participantId => {
    const isLocal = participantId === LOCAL_AUDIO;
    const connectionState = connectionStates[participantId] || 'new';
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∏–º–µ–Ω –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback
    const participantName = participantNames[participantId] || 
      (isLocal ? (currentPlayerName || '–í—ã') : `–ò–≥—Ä–æ–∫ ${participantId.slice(0, 6)}`);
    
    return {
      id: participantId,
      name: participantName,
      isLocal,
      isMuted: isLocal ? isMuted : false,
      isSpeaking: false, // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ—á–∏
      connectionState,
      volume: getParticipantVolume(participantId)
    };
  });

  return {
    participants: participantsWithInfo,
    isConnected,
    connectionStates,
    isInitializing,
    isMuted,
    joinVoiceChat,
    leaveVoiceChat,
    toggleMute,
    forcePlayAllAudio,
    setParticipantVolume,
    volumes
  };
};
